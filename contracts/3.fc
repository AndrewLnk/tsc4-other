() recv_internal() {
}

int tlen(tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
(int) ubitsize (int a) asm "UBITSIZE";

;; convert int bits to tuple
(tuple) int_to_bits(int v)
{
  var size = ubitsize(v);
  var c = begin_cell().store_int(v, size + 1).end_cell();
  var s = c.begin_parse();
  s~load_uint(1);

  var list = empty_tuple();
  repeat (size)
  {
    list~tpush(s~load_uint(1));
  }

  return list;
}

;; write first items of t to builder
(builder, tuple) store_to_builder_t(builder b, tuple builders, tuple t)
{
  var to = t.tlen();
  if ((builder_bits(b) + to) < 1023)
  {
    var i = 0;
    repeat (to)
    {
      b~store_uint(t.at(i), 1);
      i += 1;
    }
    return (b, builders);
  }
  else
  {
    builders~tpush(b);
    var nb = begin_cell();
    var i = 0;
    repeat (to)
    {
      nb~store_uint(t.at(i), 1);
      i += 1;
    }
    return (nb, builders);
  }
}

(tuple) build_flow(tuple flag, tuple value, cell linked_list)
{
  var flen = flag.tlen();
  
  var temp = empty_tuple();
  var tl = 0;
  var cache = empty_tuple();
  
  var sl = linked_list.begin_parse();
  var b = begin_cell();
  var builders = empty_tuple();
  
  var continue = slice_bits(sl) > 0;
  while(continue)
  {
    while (slice_bits(sl) > 0)
    {
      int next = 0;
      
      if (cache.tlen() > 0)
      {
        next = cache~tpop();
      }
      else
      {
        next = sl~load_uint(1);
      }
      
      if (next == flag.at(tl))
      {
        temp~tpush(next);
        tl += 1;
        
        if (tl == flen)
        {
          (b, builders) = store_to_builder_t(b, builders, value);
          temp = empty_tuple();
          tl = 0;
        }
      }
      else
      {
        if (tl > 0)
        {
          (b, builders) = store_to_builder(b, builders, temp.at(0));
          temp = remove_first_i(temp, 1);
          temp~tpush(next);
          
          repeat (tl){
            var t = temp~tpop();
            cache~tpush(t);
          }

          temp = empty_tuple();
          tl = 0;
        }
        else
        {
          (b, builders) = store_to_builder(b, builders, next);
        }
      }
    }
    
    if (slice_refs(sl) > 0)
    {
      sl = (sl~load_ref()).begin_parse();
    }
    else
    {
      continue = false;
    }
  }
  
  ;; Ok for opt
  if (tl > 0)
  {
    (b, builders) = store_to_builder_t(b, builders, temp);
  }

  repeat (cache.tlen())
  {
    (b, builders) = store_to_builder(b, builders, cache~tpop());
  }

  builders~tpush(b);
  
  return builders;
}

(builder, tuple) store_to_builder(builder b, tuple builders, int i)
{
  if (builder_bits(b) < 1023)
  {
    return (b.store_uint(i, 1), builders);
  }
  else
  {
    builders~tpush(b);
    return (begin_cell().store_uint(i, 1), builders);
  }
}

(tuple) remove_first_i(tuple t, int r)
{
  var overwrite = empty_tuple();
  var i = r;
  repeat (t.tlen() - r)
  {
     overwrite~tpush(t.at(i));
     i += 1;
  }

  return  overwrite;
}

(cell) build_tree(tuple builders)
{
;;   var b = builders~tpop();
;;   var i = 0;
;;   while (i < builders.tlen()){
;;     var next = builders~tpop();
;;     b = b.store_ref(next.end_cell());
;;   }
  
      var b = builders.first();
      builders = remove_first_i(builders, 1);
      var i = 0;
      while (i < builders.tlen()){
        var next = builders.first();
        builders = remove_first_i(builders, 1);
        b = b.store_ref(next.end_cell());
      }
  
  return b.end_cell();
}

;; testable
(cell) find_and_replace(int flag, int value, cell linked_list) method_id 
{
  ;; Ok for opt
  if ((flag <= 0) | (value <= 0))
  {
    return null();
  }

  ;; Ok for opt
  var tupleF = int_to_bits(flag);
  var tupleV = int_to_bits(value);

  var builders = build_flow(tupleF, tupleV, linked_list);
  
  if (builders.tlen() == 0){
    return null();
  }
  return build_tree(builders);
}
