() recv_internal() {
}

int tlen(tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
(int) ubitsize (int a) asm "UBITSIZE";

;; convert int bits to tuple
(tuple) int_to_bits(int v)
{
  var size = ubitsize(v);
  var c = begin_cell().store_int(v, size + 1).end_cell();
  var s = c.begin_parse();
  s~load_uint(1);

  var list = empty_tuple();
  repeat (size)
          {
            list~tpush(s~load_uint(1));
          }

  return list;
}

;; write first items of t to builder
(builder) store_to_builder_to(builder b, tuple t, int to)
{
  if ((builder_bits(b) + to) < 1023)
  {
    var i = 0;
    repeat (to)
    {
      b~store_uint(t.at(i), 1);
      i += 1;
    }
    return b;
  }
  else
  {
    var i = 0;
    b = begin_cell().store_uint(t.at(i), 1).store_ref(b.end_cell());
    repeat (to - 1)
    {
      i += 1;
      b~store_uint(t.at(i), 1);
    }
    return b;
  }
}

;; Return how can be removed by with + zeros
(int) check_is_zero_line(tuple t, int with)
{
  repeat (t.tlen() - with)
  {
    if (t.at(with) == 0)
    {
      with += 1;
    }
    else
    {
      return with;
    }
  }
  return with;
}

;; main entry of analyze
(cell) build_flow(tuple flag, tuple value, cell linked_list)
{
  var flen = flag.tlen();
  var vlen = value.tlen();

  var temp = empty_tuple();
  var templ = 0;
  var sl = linked_list.begin_parse();
  var b = begin_cell();
  
  var continue = slice_bits(sl) != 0;
  while(continue)
  {
    repeat (slice_bits(sl))
    {
      var next = sl~load_uint(1);
      
      if (next == flag.at(templ))
      {
        temp~tpush(next);
        templ += 1;
        
        if (templ == flen)
        {
          b = store_to_builder_to(b, value, vlen);
          temp = empty_tuple();
          templ = 0;
        }
      }
      else
      {
        if (templ != 0)
        {
          temp~tpush(next);
          var plane_remove = 1;
          
          var loop = true;
          while (loop & templ != 0)
          {
            ;; Remove first and next zero items
            var zero_count = check_is_zero_line(temp, plane_remove);
            b = store_to_builder_to(b, temp, zero_count);
            temp = remove_first_i(temp, zero_count);
            templ -= zero_count - plane_remove;
            plane_remove = 0;

            ;; Collect count of with == flag items
            var i = 0;
            var break = false;
            repeat (templ)
            {
              ifnot (break)
              {
                if ((break == 0) & temp.at(i) == flag.at(i))
                {
                  i += 1;
                }
                else
                {
                  break = true;
                }
              }
            }

            ;; Remove if needed and continue ...
            if ((i > 0) & (i != templ))
            {
              if (i > 1)
              {
                if (temp.at(1) == flag.at(0))
                {
                  i = 1;
                }
              }
              
              b = store_to_builder_to(b, temp, i);
              temp = remove_first_i(temp, i);
              templ -= i;
            }
            else
            {
              loop = false;
            }
          }
        }
        else
        {
          b = store_to_builder(b, next);
        }
      }
    }
    
    if (slice_refs(sl) != 0)
    {
      sl = (sl~load_ref()).begin_parse();
    }
    else
    {
      continue = false;
    }
  }

  ;; Ok for opt
  if (templ > 0)
  {
    b = store_to_builder_to(b, temp, templ);
  }
  
  return b.end_cell();
}

(builder) store_to_builder(builder b, int i)
{
  if (builder_bits(b) < 1023)
  {
    return b.store_uint(i, 1);
  }
  else
  {
    return begin_cell().store_uint(i, 1).store_ref(b.end_cell());
  }
}

(tuple) remove_first_i(tuple t, int r)
{
  var overwrite = empty_tuple();
  var i = r;
  repeat (t.tlen() - r)
  {
     overwrite~tpush(t.at(i));
     i += 1;
  }

  return  overwrite;
}

(cell) revert_tree(cell tree)
{
  var s = tree.begin_parse();
  builder reverted = null();
  var filled = 0;
  
  while (slice_empty?(s) == 0)
  {
    if (s.slice_refs() > 0)
    {
      var ref = (s~load_ref()).begin_parse();
      
      if (filled == 0)
      {
        reverted = begin_cell().store_slice(s);
        filled = 1;
      }
      else
      {
        reverted = begin_cell().store_slice(s).store_ref(reverted.end_cell());
      }
      
      s = ref;
    }
    else
    {
      if (filled == 0)
      {
        return begin_cell().store_slice(s).end_cell();
      }
      else
      {
        return begin_cell().store_slice(s).store_ref(reverted.end_cell()).end_cell();
      }
    }
  }

  return begin_cell().end_cell();
}

;; testable
(cell) find_and_replace(int flag, int value, cell linked_list) method_id 
{
  ;; Ok for opt
  if ((flag <= 0) | (value <= 0))
  {
    return null();
  }

  ;; Ok for opt
  var tupleF = int_to_bits(flag);
  var tupleV = int_to_bits(value);

  var tree = build_flow(tupleF, tupleV, linked_list);
  
  return revert_tree(tree);
}
