() recv_internal() {
}

int tlen(tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
(int) ubitsize (int a) asm "UBITSIZE";

;; convert int bits to tuple
(tuple) int_to_bits(int v)
{
  var size = ubitsize(v);
  var c = begin_cell().store_int(v, size + 1).end_cell();
  var s = c.begin_parse();
  s~load_uint(1);

  var list = empty_tuple();
  repeat (size)
  {
    list~tpush(s~load_uint(1));
  }

  return list;
}

;; write first items of t to builder
(builder) store_to_builder_t(builder b, tuple t)
{
  var i = 0;
  repeat (t.tlen())
  {
    b~store_uint(t.at(i), 1);
    i += 1;
  }
  return b;
}

(cell) build_flow(tuple flag, tuple value, cell linked_list)
{
  var flen = flag.tlen();
  
  var temp = empty_tuple();
  var tl = 0;
  var cache = empty_tuple();
  
  var sl = linked_list.begin_parse();
  var b = begin_cell();
  
  var continue = slice_bits(sl) > 0;
  while(continue)
  {
    while (slice_bits(sl) > 0)
    {
      int next = 0;
      
      if (cache.tlen() > 0)
      {
        next = cache~tpop();
      }
      else
      {
        next = sl~load_uint(1);
      }
      
      if (next == flag.at(tl))
      {
        temp~tpush(next);
        tl += 1;
        
        if (tl == flen)
        {
          b = store_to_builder_t(b, value);
          temp = empty_tuple();
          tl = 0;
        }
      }
      else
      {
        if (tl > 0)
        {
          b = store_to_builder(b, temp.at(0));
          temp = remove_first_i(temp, 1);
          temp~tpush(next);
          
          repeat (tl){
            var t = temp~tpop();
            cache~tpush(t);
          }

          temp = empty_tuple();
          tl = 0;
        }
        else
        {
          b = store_to_builder(b, next);
        }
      }
    }
    
    if (slice_refs(sl) > 0)
    {
      sl = (sl~load_ref()).begin_parse();
    }
    else
    {
      continue = false;
    }
  }
  
  ;; Ok for opt
  if (tl > 0)
  {
    b = store_to_builder_t(b, temp);
  }
  
  repeat (cache.tlen()){
    b = store_to_builder(b, cache~tpop());
  }
  
  return b.end_cell();
}

(builder) store_to_builder(builder b, int i)
{
  return b.store_uint(i, 1);
}

(tuple) remove_first_i(tuple t, int r)
{
  var overwrite = empty_tuple();
  var i = r;
  repeat (t.tlen() - r)
  {
     overwrite~tpush(t.at(i));
     i += 1;
  }

  return  overwrite;
}

(cell) revert_tree(cell tree)
{
  var s = tree.begin_parse();
  builder reverted = null();
  var filled = 0;
  
  while (slice_empty?(s) == 0)
  {
    if (s.slice_refs() > 0)
    {
      var ref = (s~load_ref()).begin_parse();
      
      if (filled == 0)
      {
        reverted = begin_cell().store_slice(s);
        filled = 1;
      }
      else
      {
        reverted = begin_cell().store_slice(s).store_ref(reverted.end_cell());
      }
      
      s = ref;
    }
    else
    {
      if (filled == 0)
      {
        return begin_cell().store_slice(s).end_cell();
      }
      else
      {
        return begin_cell().store_slice(s).store_ref(reverted.end_cell()).end_cell();
      }
    }
  }

  return begin_cell().end_cell();
}

;; testable
(cell) find_and_replace(int flag, int value, cell linked_list) method_id 
{
  ;; Ok for opt
  if ((flag <= 0) | (value <= 0))
  {
    return null();
  }

  ;; Ok for opt
  var tupleF = int_to_bits(flag);
  var tupleV = int_to_bits(value);

  var tree = build_flow(tupleF, tupleV, linked_list);
  return revert_tree(tree);
}
